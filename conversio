#!/usr/bin/env ruby 

$DEBUG = false

require 'rubygems'
require 'erb'
require 'yaml'
require 'ftools'
require 'fileutils'
require 'pathname'
require 'getoptlong'
require 'lib/pygmentizer'
require 'lib/converter'
require 'lib/htmltoc'


help = <<EOF
Synopsis
--------

  #{File.split(__FILE__)[-1]}: Renders Markdown plain text files to HTML 

Purpose
-------

Uses Ruby ERB Templates to generate XHTML documents rendered from Markdown
plain text files.

Usage
-----

#{File.split(__FILE__)[-1]} [OPTIONS] SRC [DST]

SRC: File or directory containing the Markdown formated plain text
DST: Target directory for the XHTML output.

Options
-------

--config:

  Creates a personal configuration file in ~/.conversiorc

-c, --colorize:

  Enable syntax high-lighting for marked code blocks.

-e, --engine:

  Select the Markdown parser to be used:
  * 'bluecloth' (default)
  * 'kramdown'

-i, --ignore-config:

  Don't read the configuration from ~/.conversiorc

-h, --help:

  show help

-s --style DST:

  Write a resonable default CSS configuration to DST.

-t, --toc:

  Enables the creation of a table of content.

--template FILE:

  FILE containing an ERB template with:
  * '<%= content %>' to mark the postion inside the body tag
    to place the passed in content.
  * '<%= style %>' to mark the position for placing CSS.

--template-default:

  Prints the default template used when no template is specified
  by the user. Take it as an very simple example to write your
  own template files.

-v, --verbose:

  Print more verbose output.
EOF

default_template = <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="./style/reset.css" rel="stylesheet" type="text/css"> 
  <link href="./style/content.css" rel="stylesheet" type="text/css"> 
  <link href="./style/pygments.css" rel="stylesheet" type="text/css"> 
  <link href="./style/default.css" rel="stylesheet" type="text/css"> 
</head>
<body>
<div id="display">
  <div id="content">
    <%= @content %>
  </div>
</div>
</body>
</html>
EOF

config = <<EOF
color = true
toc = true
# template = 'path/to/file'
EOF


def load_lib(name)
  begin 
      require name
  rescue LoadError
    $stderr.puts "Loading library #{name} failed!"
    exit 1
  end
end

# -------------------------------------------------------------
# class extensions
# -------------------------------------------------------------

class Array
  def resolv_path
    Hash[ *self.collect { |e| [e,e.gsub(/.markdown/,'.html') ] }.flatten ]
  end
end

# -------------------------------------------------------------
# main program
# -------------------------------------------------------------
begin

  user_config = "#{ENV['HOME']}/.conversiorc"

  # default values
  style = nil
  template = nil
  engine = nil
  toc = false
  color = false
  verbose = false
  ignore = false

  # list of user options
  opts = GetoptLong.new(
    [ '--colorize', '-c', GetoptLong::NO_ARGUMENT],
    [ '--config', GetoptLong::NO_ARGUMENT],
    [ '--engine', '-e', GetoptLong::OPTIONAL_ARGUMENT],
    [ '--ignore-config', '-i', GetoptLong::NO_ARGUMENT],
    [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
    [ '--style', '-s', GetoptLong::OPTIONAL_ARGUMENT],
    [ '--toc', '-t', GetoptLong::NO_ARGUMENT],
    [ '--template', GetoptLong::OPTIONAL_ARGUMENT ],
    [ '--template-default', GetoptLong::NO_ARGUMENT ],
    [ '--verbose', '-v', GetoptLong::NO_ARGUMENT]
  )

  # parse the options from the command line
  opts.each do |opt, arg|
    case opt
    when '--colorize'
      color = true
    when '--config'
      open("#{ENV['HOME']}/.conversiorc",'w') { |f| f.write config }
      exit 0
    when '--engine'
      engine = arg
    when '--ignore-config'
      ignore = true
    when '--help' 
      puts help
      exit 0
    when '--style'
      FileUtils::Verbose.cp_r('resources/css/.',"#{arg}/style/")
      exit 0
    when '--toc'
      toc = true
    when '--template' 
      template = open( arg ){ |file| file.read } if File.exist?(arg)
    when '--template-default' 
      puts default_template
      exit 0
    when '--verbose'
      verbose = true
    end
  end

  # get the input source
  src = ARGV[0] || raise("no input defined")
  dst = ARGV[1] # optional parameter!

  # read the default configuration of the user  
  if not ignore and  File.exists? user_config then
    eval open(user_config).readlines.join
  end
    
  
  # user the default XHTML template if the user hasn't defined its own
  template = default_template if template.nil? 
  converter = Converter.new(template)
  converter.load_parser(engine) unless engine.nil?
  converter.color = true if color
  converter.table_of_content = true if toc
  # get all the input files
  input_files = Array.new
  if File.directory?(src) then
    input_files = Dir["#{src}/**/*.markdown"]
  else
    file = File.expand_path(src)
    input_files << file
    src = File.dirname(file) 
  end
  src_dst_pairs = input_files.resolv_path
  # fix the destination path if needed
  unless dst.nil? then
    src_dst_pairs.each_pair do |src_path,dst_path|
      src_dst_pairs[src_path] = dst_path.gsub(/#{src}/,dst)      
    end
  end
  # render the XHTML docs
  src_dst_pairs.each_pair { |s,d| converter.markdown_to_xhtml(s,d) }

  exit 0

rescue => exc
  STDERR.puts "ERROR: #{exc.message}"
  STDERR.puts "  use -h for detailed instructions"
  exit 1
end

